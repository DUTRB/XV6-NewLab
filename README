xv6 is a re-implementation of Dennis Ritchie's and Ken Thompson's Unix
Version 6 (v6).  xv6 loosely follows the structure and style of v6,
but is implemented for a modern RISC-V multiprocessor using ANSI C.


在实验中，实现了trace和sysinfo两个新的系统调用。需要知道的是系统调用system call的大部分工作都是在有特权的内核态模式下进行操作，在RISC-V中，ecall指令使得操作系统由用户态切换至内核态，我们从特定的寄存器中读取到究竟是哪个系统调用造成了内核态切换并读取，传入相关的参数。

- 用户在trace.c中使用提供的系统调用接口 int trace(int)
- 接口的实现由 perl 脚本生成的汇编代码实现，将SYS_trace的代号放入a7寄存器，由ecall硬件支持由用户态转入内核态。（ecall指令用于主动触发异常，异常产生时epc寄存器的值存放的是ecall指令的地址）
- 控制转入系统调用的通用入口 void syscall(void)函数（这个函数有可能是在trap中断处理函数中），由a7寄存器读出需要被调用的系统调用是哪个，从 uint64 (*syscall[])(void) 这个函数指针数组跳转到具体的系统调用函数实现上，将返回值存入a0寄存器。
- 此时从ecall返回，汇编指令ret使得用户侧的系统调用接口返回。